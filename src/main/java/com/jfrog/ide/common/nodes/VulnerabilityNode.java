package com.jfrog.ide.common.nodes;

import com.fasterxml.jackson.annotation.JsonProperty;
import com.jfrog.ide.common.nodes.subentities.ApplicableInfo;
import com.jfrog.ide.common.nodes.subentities.Cve;
import com.jfrog.ide.common.nodes.subentities.ResearchInfo;
import com.jfrog.ide.common.nodes.subentities.Severity;
import org.apache.commons.lang3.StringUtils;

import java.util.List;
import java.util.Objects;

import static com.jfrog.ide.common.nodes.subentities.Severity.getNotApplicableSeverity;

/**
 * @author yahavi
 */
public class VulnerabilityNode extends IssueNode {
    @JsonProperty()
    private String ignoreRuleUrl;
    @JsonProperty()
    private Severity severity = Severity.Normal;
    @JsonProperty()
    private List<String> fixedVersions;
    @JsonProperty()
    private List<String> infectedVersions;
    @JsonProperty()
    private List<String> references;
    @JsonProperty()
    private Cve cve;
    @JsonProperty()
    private String summary;
    @JsonProperty()
    private String issueId;
    @JsonProperty()
    private String lastUpdated;
    @JsonProperty()
    private List<String> watchNames;
    @JsonProperty()
    private ResearchInfo researchInfo;
    @JsonProperty()
    private ApplicableInfo applicableInfo;

    // Empty constructor for deserialization
    @SuppressWarnings("unused")
    private VulnerabilityNode() {
    }

    @SuppressWarnings("unused")
    public VulnerabilityNode(String issueId, Severity severity, String summary, List<String> fixedVersions, List<String> infectedVersions,
                             Cve cve, String lastUpdated, List<String> watchNames, List<String> references, ResearchInfo researchInfo, String ignoreRuleUrl) {
        this.issueId = issueId;
        this.severity = severity;
        this.summary = summary;
        this.fixedVersions = fixedVersions;
        this.infectedVersions = infectedVersions;
        this.cve = cve;
        this.lastUpdated = lastUpdated;
        this.watchNames = watchNames;
        this.references = references;
        this.researchInfo = researchInfo;
        this.ignoreRuleUrl = ignoreRuleUrl;
    }

    public String getIssueId() {
        return this.issueId;
    }

    public Severity getSeverity() {
        return isApplicable() != null && !isApplicable() ? getNotApplicableSeverity(severity) : severity;
    }

    public Severity getSeverity(boolean masked) {
        if (!masked) {
            return this.severity;
        }
        return getSeverity();
    }

    @SuppressWarnings("unused")
    public String getSummary() {
        return summary;
    }

    @SuppressWarnings("unused")
    public List<String> getFixedVersions() {
        return fixedVersions;
    }

    @SuppressWarnings("unused")
    public void setFixedVersions(List<String> fixedVersions) {
        this.fixedVersions = fixedVersions;
    }

    @SuppressWarnings("unused")
    public List<String> getInfectedVersions() {
        return infectedVersions;
    }

    @SuppressWarnings("unused")
    public List<String> getReferences() {
        return references;
    }

    public Cve getCve() {
        return cve;
    }

    public String getLastUpdated() {
        return lastUpdated;
    }

    public List<String> getWatchNames() {
        return watchNames;
    }

    @SuppressWarnings("unused")
    public ResearchInfo getResearchInfo() {
        return researchInfo;
    }

    public ApplicableInfo getApplicableInfo() {
        return applicableInfo;
    }

    /**
     * If no previous applicability evidences exist, set the applicable info as "no applicable".
     */
    public void setNotApplicable() {
        if (this.applicableInfo == null) {
            this.applicableInfo = new ApplicableInfo(false);
        }
    }

    public void updateApplicableInfo(ApplicableIssueNode issue) {
        if (this.applicableInfo == null) {
            this.applicableInfo = new ApplicableInfo(true, issue.getScannerSearchTarget(), issue.getReason(), issue.getFilePath(), issue.getLineSnippet());
        } else {
            applicableInfo.addInfo(issue.getReason(), issue.getFilePath(), issue.getLineSnippet());
        }
    }

    /**
     * Returns true if the issue is applicable, false if not.
     * If the applicability status is unknown, null will be returned.
     */
    public Boolean isApplicable() {
        return this.applicableInfo != null ? this.applicableInfo.isApplicable() : null;
    }

    @SuppressWarnings("unused")
    public String getIgnoreRuleUrl() {
        return ignoreRuleUrl;
    }

    private String getCveIdOrEmpty() {
        if (cve == null) {
            return "";
        }
        return cve.getCveId();
    }

    @Override
    public String getTitle() {
        return StringUtils.firstNonBlank(getCveIdOrEmpty(), issueId);
    }

    @Override
    public String getSubtitle() {
        return null;
    }

    @Override
    public String toString() {
        return getTitle();
    }

    @Override
    public boolean equals(Object other) {
        if (!(other instanceof VulnerabilityNode)) {
            return false;
        }
        VulnerabilityNode otherIssue = (VulnerabilityNode) other;
        return StringUtils.equals(otherIssue.getIssueId(), getIssueId()) &&
                StringUtils.equals(otherIssue.getCveIdOrEmpty(), getCveIdOrEmpty());
    }

    @Override
    public int hashCode() {
        return Objects.hash(issueId, cve);
    }
}
